# Why 32-Byte IDs Are More Secure Than UUIDs for Object Access

## Executive Summary

UUIDs (16 bytes) are widely used but have security weaknesses when used as secret access tokens. 32-byte random IDs provide significantly stronger protection against brute-force attacks, even at the cost of doubled storage.

## UUID Vulnerabilities

### UUID v1 / v6 / v7: Time-Based Weakness

These versions embed timestamps, making them predictable:

| Component | Bits Revealed |
|-----------|---------------|
| Timestamp | 48-60 bits |
| MAC address (v1) | 48 bits |
| Version/variant | 6 bits |

**Attack scenario**: If an attacker knows the approximate creation time:

| Attacker Knowledge | Bits to Guess | Attempts Needed |
|--------------------|---------------|-----------------|
| None | ~122 bits | 2¹²² |
| Time window (1 day) | ~80 bits | 2⁸⁰ |
| Time window (1 hour) | ~70 bits | 2⁷⁰ |
| Time window (1 minute) | ~64 bits | 2⁶⁴ |
| Time window (1 second) | ~54 bits | 2⁵⁴ |
| Time + MAC address | ~14 bits | ~16,000 |

With time + MAC knowledge, brute force becomes trivial.

### Real-World Attack Vectors

**How attackers obtain time information:**

| Source | Precision |
|--------|-----------|
| HTTP response headers | Second |
| Email timestamps | Second |
| API rate limit reset times | Second |
| User registration confirmation | Minute |
| Public activity logs | Minute |
| Social media posts | Minute |
| Invoice/order dates | Day |

**How attackers obtain MAC addresses:**

| Source | Method |
|--------|--------|
| Network traffic | ARP requests on same network |
| UUID v1 itself | MAC is embedded in last 12 hex chars |
| Device fingerprinting | WebRTC leaks |
| Public records | Device registrations |

### UUID v4: Better, But Still Limited

UUID v4 is random but only provides ~122 bits of entropy (6 bits reserved for version/variant).

| Scenario | Collision/Guess Risk |
|----------|----------------------|
| 10⁹ objects | ~2⁹² guesses to find one |
| 10¹² objects | ~2⁸² guesses to find one |
| 10¹⁸ objects | ~2⁶² guesses to find one |

At massive scale, 122 bits becomes increasingly vulnerable.

## 32-Byte Random IDs

### Full 256-Bit Entropy

```
32 bytes = 256 bits = 2²⁵⁶ possible values
```

### Comparison

| Property | UUID v4 (16 bytes) | Random 32 bytes |
|----------|--------------------| ----------------|
| Total bits | 128 | 256 |
| Effective entropy | ~122 bits | 256 bits |
| Time leakage | None | None |
| Guesses for 1 in 10⁹ | 2⁹² | 2²²⁶ |
| Quantum resistant (Grover's) | No (2⁶¹) | Yes (2¹²⁸) |

### Brute Force Comparison

| Attempts/sec | Time to guess UUID v4 | Time to guess 32-byte |
|--------------|-----------------------|-----------------------|
| 10⁹ | ~10²⁰ years | ~10⁵⁰ years |
| 10¹² | ~10¹⁷ years | ~10⁴⁷ years |
| 10¹⁵ | ~10¹⁴ years | ~10⁴⁴ years |

## Storage Cost Analysis

### Memory Impact

| Scale | UUID Storage | 32-Byte Storage | Difference |
|-------|--------------|-----------------|------------|
| 1 million | 16 MB | 32 MB | +16 MB |
| 1 billion | 16 GB | 32 GB | +16 GB |
| 1 trillion | 16 TB | 32 TB | +16 TB |

### Cost Perspective

At current cloud storage prices (~$0.02/GB/month):

| Scale | Extra Monthly Cost |
|-------|--------------------|
| 1 million IDs | $0.00032 |
| 1 billion IDs | $0.32 |
| 1 trillion IDs | $320 |

The security gain far outweighs the storage cost.

## Storage Formats

| Format | Length | Example |
|--------|--------|---------|
| Hex | 64 characters | a3f2b1c4d5e6... |
| Base64 | 44 characters | o/KxxD2... |
| Binary | 32 bytes | Most compact |


## Conclusion

For any ID that grants access to sensitive resources, use 32-byte random IDs. The doubled storage cost is negligible compared to the exponentially stronger security guarantee. UUIDs remain suitable for non-secret identifiers where guessability is not a concern.
\pagebreak